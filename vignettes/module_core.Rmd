---
title: "Core Module"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Core Module}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette provides documentation for the core module available within any LaminDB instance. Unlike traditional R packages with a fixed set of functions, LaminDB allows customization through modules and extensions. This means the specific registries and their fields in your LaminDB instance are determined by its schema.

For reference, here is the documentation on the [core module](https://docs.lamin.ai/api#) for the LaminDB Python package.

## Key Concepts

In **LaminDB**, data and metadata are organized using a system of 
registries and modules.

 * **Registries**: Centralized collections of related records, similar to database tables. Each registry stores specific types of metadata (e.g., artifacts, transforms, features).
 * **Modules**: Groupings of related registries that provide domain-specific functionality. The core module is fundamental to all LaminDB instances and includes essential registries for general data management. Other modules (like bionty for biological entities) can be added to extend functionality.
 * **Records and Fields**: A record is a single entry within a registry, analogous to a row in a database table. Each record comprises multiple fields, which are individual pieces of information within the record.

For a more comprehensive explanation of the **LaminDB** concepts and **{laminr}**'s architecture, refer to the **Architecture vignette**: `vignette("architecture", package = "laminr")`.

To learn how to connect to a LaminDB instance and perform basic operations, see the **Getting started** vignette: `vignette("laminr", package = "laminr")`.

```{r connect, include = FALSE}
library(laminr)
library(purrr)

db <- connect("laminlabs/lamindata")

core <- db$get_module("core")
```

```{r generate_docs, echo = FALSE, results = "asis"}
registry_names <- core$get_registry_names()
type_map <- c(
  "BigAutoField" = "integer64",
  "AutoField" = "integer",
  "CharField" = "character",
  "BooleanField" = "logical",
  "DateTimeField" = "POSIXct",
  "TextField" = "character",
  "ForeignKey" = "integer64",
  "BigIntegerField" = "integer64",
  "SmallIntegerField" = "integer",
  "JSONField" = "list"
)


for (registry_name in registry_names) { # nolint cyclocomp_linter
  registry <- core$get_registry(registry_name)
  fields <- registry$get_fields()

  if (registry$is_link_table) {
    next
  }

  cat(paste0("## ", registry$class_name, "\n\n"))

  classes <- class(registry) |> discard(~ .x == "R6")
  class_urls <- paste0("`?", classes, "`")

  cat(paste0("Bases: ", paste(class_urls, collapse = ", "), "\n\n"))

  cat(paste0("### Simple fields\n\n"))

  simple_fields <- fields |> keep(
    ~ is.null(.x$related_field_name) &&
      !grepl("^_", .x$field_name)
  )

  for (field in simple_fields) {
    field_type <-
      if (field$type %in% names(type_map)) {
        type_map[[field$type]]
      } else {
        field$type
      }
    cat(paste0("* `", field$field_name, "` (`", field_type, "`)\n"))
  }

  cat("\n\n")

  cat(paste0("### Relational fields\n\n"))

  relational_fields <- fields |> keep(
    ~ !is.null(.x$related_field_name) &&
      !grepl("^_", .x$field_name) &&
      !.x$is_link_table &&
      .x$related_module_name == "core"
  )

  for (field in relational_fields) {
    related_module <- db$get_module(field$related_module_name)
    related_registry <- related_module$get_registry(field$related_registry_name)
    cat(paste0("* `", field$field_name, "` ([`", related_registry$class_name, "`](#", related_registry$name, "))\n"))
  }

  cat("\n\n")
}
```
